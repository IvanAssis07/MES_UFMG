{
  "data": {
    "submissionDetails": {
      "runtime": 5,
      "runtimeDisplay": "5 ms",
      "runtimePercentile": 68.52780000000001,
      "runtimeDistribution": "{\"lang\": \"python3\", \"distribution\": [[\"1\", 25.1265], [\"3\", 8.0996], [\"5\", 4.1911000000000005], [\"7\", 0.7424], [\"10\", 0.17729999999999999], [\"12\", 0.0459], [\"14\", 0.0657], [\"16\", 0.0131], [\"19\", 0.0132], [\"21\", 0.046], [\"23\", 0.0131], [\"26\", 0.0131], [\"28\", 0.0328], [\"30\", 0.20370000000000002], [\"32\", 0.1314], [\"35\", 0.8343], [\"37\", 0.7094], [\"39\", 0.1379], [\"41\", 0.1314], [\"44\", 0.0197], [\"46\", 0.0592], [\"48\", 0.0132], [\"50\", 0.0066], [\"53\", 0.0197], [\"55\", 0.0394], [\"57\", 0.5387], [\"59\", 0.7226], [\"62\", 2.9560000000000004], [\"64\", 1.143], [\"66\", 1.905], [\"69\", 1.1168], [\"71\", 0.12480000000000001], [\"73\", 0.092], [\"75\", 0.0262], [\"78\", 0.0722], [\"80\", 0.092], [\"82\", 0.2365], [\"84\", 0.1511], [\"87\", 1.4321], [\"89\", 5.1304], [\"91\", 2.4305], [\"93\", 10.687700000000001], [\"96\", 3.7115], [\"98\", 6.5231], [\"100\", 1.7934], [\"102\", 2.8773], [\"105\", 1.4057000000000002], [\"107\", 0.5649], [\"109\", 1.3664], [\"111\", 0.7817], [\"114\", 0.8408], [\"116\", 0.2561], [\"118\", 0.4073], [\"121\", 0.2364], [\"123\", 0.0459], [\"125\", 0.1248], [\"127\", 0.052500000000000005], [\"130\", 0.15109999999999998], [\"132\", 0.0854], [\"134\", 0.1248], [\"136\", 0.1444], [\"139\", 0.0723], [\"141\", 0.197], [\"143\", 0.0722], [\"145\", 0.2891], [\"148\", 0.092], [\"150\", 0.2299], [\"152\", 0.0789], [\"154\", 0.289], [\"157\", 0.24309999999999998], [\"159\", 0.1248], [\"161\", 0.2825], [\"164\", 0.2102], [\"166\", 0.2759], [\"168\", 0.14450000000000002], [\"170\", 0.4073], [\"173\", 0.3153], [\"175\", 0.09849999999999999], [\"177\", 0.2168], [\"179\", 0.0789]]}",
      "memory": 19572000,
      "memoryDisplay": "19.6 MB",
      "memoryPercentile": 61.10499999999999,
      "memoryDistribution": "{\"lang\": \"python3\", \"distribution\": [[\"18300\", 0.0263], [\"18400\", 0.1182], [\"18500\", 0.4401], [\"18600\", 0.762], [\"18700\", 0.7817], [\"18800\", 1.0051], [\"18900\", 1.3532], [\"19000\", 3.0546], [\"19100\", 8.0076], [\"19200\", 11.522], [\"19300\", 6.2274], [\"19400\", 2.8312], [\"19500\", 2.7656], [\"19600\", 2.7064], [\"19700\", 1.0642], [\"19800\", 0.2825], [\"19900\", 0.1774], [\"20000\", 0.0591], [\"20100\", 0.0591], [\"20200\", 0.0263], [\"20300\", 0.0131], [\"20400\", 0.0328], [\"20500\", 0.0131], [\"20600\", 0.0131], [\"20700\", 0.0066], [\"20800\", 0.0066], [\"21200\", 0.0066], [\"21300\", 0.0066], [\"21400\", 0.0066], [\"21500\", 0.0131], [\"21600\", 0.0066], [\"21700\", 0.0066], [\"21900\", 0.0131], [\"22100\", 0.0131], [\"22200\", 0.0066], [\"22500\", 0.0066], [\"23900\", 0.0066], [\"41800\", 0.0066], [\"41900\", 0.0197], [\"42000\", 0.0066], [\"42100\", 0.0131], [\"44300\", 0.0066], [\"53400\", 0.0131], [\"53500\", 0.0328], [\"53600\", 0.1708], [\"53700\", 0.3941], [\"53800\", 1.4058], [\"53900\", 2.9429], [\"54000\", 2.4634], [\"54100\", 1.2153], [\"54200\", 0.3679], [\"54300\", 0.2036], [\"54400\", 0.1182], [\"54500\", 0.092], [\"54600\", 0.0131], [\"54700\", 0.0131], [\"54800\", 0.0066], [\"55000\", 0.0066], [\"56100\", 0.0131], [\"56300\", 0.0066], [\"56400\", 0.0131], [\"56500\", 0.0131], [\"56600\", 0.0263], [\"56700\", 0.0066], [\"56800\", 0.0131], [\"88400\", 0.0066], [\"88500\", 0.0066], [\"88600\", 0.0197], [\"88700\", 0.0328], [\"88800\", 0.0394], [\"88900\", 0.2365], [\"89000\", 0.6438], [\"89100\", 2.5685], [\"89200\", 7.1931], [\"89300\", 16.0678], [\"89400\", 8.7696], [\"89500\", 2.3648], [\"89600\", 1.2415], [\"89700\", 1.6291]]}",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        # Create a dictionary to store the indices of inorder elements for quick access\n        inorder_indices = {val: idx for idx, val in enumerate(inorder)}\n        \n        def helper(pre_start, pre_end, in_start, in_end):\n            if pre_start > pre_end:\n                return None\n            \n            root_val = preorder[pre_start]\n            root = TreeNode(root_val)\n            \n            # Find the position of the root in the inorder array\n            in_root_pos = inorder_indices[root_val]\n            left_subtree_size = in_root_pos - in_start\n            \n            # Recursively build the left and right subtrees\n            root.left = helper(pre_start + 1, pre_start + left_subtree_size, in_start, in_root_pos - 1)\n            root.right = helper(pre_start + left_subtree_size + 1, pre_end, in_root_pos + 1, in_end)\n            \n            return root\n        \n        return helper(0, len(preorder) - 1, 0, len(inorder) - 1)",
      "timestamp": 1749413587,
      "statusCode": 10,
      "user": {
        "username": "ZRlvkAicEr",
        "profile": {
          "realName": "ZRlvkAicEr",
          "userAvatar": "https://assets.leetcode.com/users/ZRlvkAicEr/avatar_1749245074.png"
        }
      },
      "lang": {
        "name": "python3",
        "verboseName": "Python3"
      },
      "question": {
        "questionId": "105",
        "titleSlug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "hasFrontendPreview": false
      },
      "notes": "",
      "flagType": "WHITE",
      "topicTags": [],
      "runtimeError": null,
      "compileError": null,
      "lastTestcase": "",
      "codeOutput": "",
      "expectedOutput": "",
      "totalCorrect": 203,
      "totalTestcases": 203,
      "fullCodeOutput": null,
      "testDescriptions": null,
      "testBodies": null,
      "testInfo": null,
      "stdOutput": ""
    }
  }
}
