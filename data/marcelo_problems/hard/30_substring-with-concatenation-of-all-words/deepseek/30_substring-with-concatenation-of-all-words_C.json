
{
    "data": {
        "submissionDetails": {
            "runtime": 4,
            "runtimeDisplay": "N/A",
            "runtimePercentile": null,
            "runtimeDistribution": "{\"lang\": \"c\", \"distribution\": [[\"11\", 35.8803], [\"34\", 4.319], [\"57\", 4.3187999999999995], [\"80\", 3.6543], [\"103\", 6.644600000000001], [\"126\", 2.6578], [\"149\", 3.654299999999999], [\"172\", 0.9965999999999999], [\"195\", 0.3322], [\"218\", 0.3322], [\"241\", 0.3322], [\"264\", 0.6645], [\"287\", 3.6543999999999994], [\"310\", 0.9966999999999999], [\"333\", 0.3322], [\"356\", 0.3322], [\"379\", 0.3322], [\"402\", 0.3322], [\"425\", 0.3322], [\"448\", 0.6645], [\"471\", 0.3322], [\"494\", 0.3322], [\"517\", 0.3322], [\"540\", 0.6645], [\"563\", 0.3322], [\"586\", 0.3322], [\"609\", 0.3322], [\"632\", 0.3322], [\"655\", 0.3322], [\"678\", 0.6645], [\"701\", 0.3322], [\"724\", 0.3322], [\"747\", 0.3322], [\"770\", 0.3322], [\"793\", 0.3322], [\"816\", 0.3322], [\"839\", 0.6645], [\"862\", 0.3322], [\"885\", 0.3322], [\"908\", 0.3322], [\"932\", 0.3322], [\"955\", 0.3322], [\"978\", 0.3322], [\"1001\", 0.3322], [\"1024\", 0.9965999999999999], [\"1047\", 1.3289], [\"1070\", 1.3288], [\"1093\", 0.6644], [\"1116\", 0.3322], [\"1139\", 1.3288], [\"1162\", 0.9965999999999999], [\"1185\", 0.9965999999999999], [\"1208\", 0.6644], [\"1231\", 0.3322], [\"1254\", 0.3322], [\"1277\", 0.3322], [\"1300\", 0.3322], [\"1323\", 0.6644], [\"1346\", 0.3322], [\"1369\", 0.3322], [\"1392\", 0.3322], [\"1415\", 0.3322], [\"1438\", 0.3322], [\"1461\", 0.3322], [\"1484\", 0.3322], [\"1507\", 0.6645], [\"1530\", 0.3322], [\"1553\", 0.3322], [\"1576\", 0.3322], [\"1599\", 0.3322]]}",
            "memory": 16304000,
            "memoryDisplay": "N/A",
            "memoryPercentile": null,
            "memoryDistribution": "{\"lang\": \"c\", \"distribution\": [[\"13000\", 1.3289], [\"13100\", 3.3223], [\"13200\", 2.6578], [\"13300\", 2.99], [\"13400\", 4.3189], [\"13500\", 3.9867], [\"13600\", 8.3056], [\"13700\", 13.6213], [\"13800\", 8.6379], [\"13900\", 1.9934], [\"14000\", 2.99], [\"14100\", 0.9967], [\"14200\", 0.6645], [\"14300\", 0.6645], [\"14500\", 0.6645], [\"14600\", 0.3322], [\"14800\", 0.3322], [\"15200\", 0.6645], [\"15500\", 0.9967], [\"15600\", 1.6611], [\"15700\", 0.3322], [\"15900\", 0.6645], [\"18200\", 0.3322], [\"18800\", 0.3322], [\"19500\", 0.3322], [\"19600\", 1.6611], [\"19700\", 0.6645], [\"19800\", 0.3322], [\"19900\", 0.3322], [\"20000\", 0.3322], [\"20100\", 0.3322], [\"21200\", 0.3322], [\"21500\", 0.3322], [\"21600\", 0.3322], [\"22400\", 0.3322], [\"22600\", 0.3322], [\"22700\", 1.3289], [\"22800\", 0.6645], [\"22900\", 0.6645], [\"23000\", 0.3322], [\"23900\", 0.3322], [\"24000\", 0.3322], [\"24900\", 0.3322], [\"25100\", 0.3322], [\"25200\", 0.9967], [\"26300\", 0.3322], [\"26800\", 1.9934], [\"26900\", 1.3289], [\"27100\", 0.3322], [\"29500\", 0.3322], [\"29900\", 0.3322], [\"30200\", 0.3322], [\"30300\", 0.9967], [\"30500\", 0.6645], [\"30600\", 0.3322], [\"30800\", 0.3322], [\"32500\", 0.6645], [\"37300\", 0.3322], [\"37400\", 0.3322], [\"37500\", 0.3322], [\"39900\", 0.3322], [\"41500\", 0.3322], [\"41700\", 0.3322], [\"42700\", 0.3322], [\"42800\", 0.3322], [\"42900\", 1.3289], [\"43000\", 0.3322], [\"43100\", 0.9967], [\"43200\", 0.3322], [\"50600\", 0.3322], [\"50700\", 1.9934], [\"50800\", 0.9967], [\"50900\", 0.6645], [\"51200\", 0.3322], [\"61000\", 0.6645], [\"61100\", 0.3322], [\"61900\", 0.3322], [\"65200\", 0.3322], [\"137000\", 0.6645], [\"137500\", 0.3322]]}",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char* key;\n    int value;\n} KeyValue;\n\ntypedef struct {\n    KeyValue* items;\n    int size;\n    int capacity;\n} HashMap;\n\nHashMap* createHashMap(int capacity) {\n    HashMap* map = (HashMap*)malloc(sizeof(HashMap));\n    map->items = (KeyValue*)malloc(capacity * sizeof(KeyValue));\n    map->size = 0;\n    map->capacity = capacity;\n    for (int i = 0; i < capacity; i++) {\n        map->items[i].key = NULL;\n        map->items[i].value = 0;\n    }\n    return map;\n}\n\nvoid freeHashMap(HashMap* map) {\n    for (int i = 0; i < map->capacity; i++) {\n        if (map->items[i].key != NULL) {\n            free(map->items[i].key);\n        }\n    }\n    free(map->items);\n    free(map);\n}\n\nint hashFunction(const char* key, int capacity) {\n    unsigned long hash = 5381;\n    int c;\n    while ((c = *key++)) {\n        hash = ((hash << 5) + hash) + c; // hash * 33 + c\n    }\n    return hash % capacity;\n}\n\nvoid put(HashMap* map, const char* key, int value) {\n    int index = hashFunction(key, map->capacity);\n    while (map->items[index].key != NULL && strcmp(map->items[index].key, key) != 0) {\n        index = (index + 1) % map->capacity;\n    }\n    if (map->items[index].key == NULL) {\n        map->items[index].key = strdup(key);\n        map->size++;\n    }\n    map->items[index].value = value;\n}\n\nint get(HashMap* map, const char* key) {\n    int index = hashFunction(key, map->capacity);\n    while (map->items[index].key != NULL) {\n        if (strcmp(map->items[index].key, key) == 0) {\n            return map->items[index].value;\n        }\n        index = (index + 1) % map->capacity;\n    }\n    return 0;\n}\n\nint* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\n    *returnSize = 0;\n    if (wordsSize == 0 || strlen(s) == 0) {\n        return NULL;\n    }\n    \n    int wordLen = strlen(words[0]);\n    int totalLen = wordLen * wordsSize;\n    int sLen = strlen(s);\n    \n    if (totalLen > sLen) {\n        return NULL;\n    }\n    \n    HashMap* wordCount = createHashMap(wordsSize * 2);\n    for (int i = 0; i < wordsSize; i++) {\n        int count = get(wordCount, words[i]);\n        put(wordCount, words[i], count + 1);\n    }\n    \n    int* result = (int*)malloc(sLen * sizeof(int));\n    int resultIndex = 0;\n    \n    for (int i = 0; i <= sLen - totalLen; i++) {\n        HashMap* seen = createHashMap(wordsSize * 2);\n        int j = 0;\n        for (; j < wordsSize; j++) {\n            char* word = (char*)malloc((wordLen + 1) * sizeof(char));\n            strncpy(word, s + i + j * wordLen, wordLen);\n            word[wordLen] = '\\0';\n            \n            int expectedCount = get(wordCount, word);\n            if (expectedCount == 0) {\n                free(word);\n                break;\n            }\n            int seenCount = get(seen, word);\n            put(seen, word, seenCount + 1);\n            free(word);\n            \n            if (get(seen, word) > expectedCount) {\n                break;\n            }\n        }\n        if (j == wordsSize) {\n            result[resultIndex++] = i;\n        }\n        freeHashMap(seen);\n    }\n    \n    freeHashMap(wordCount);\n    *returnSize = resultIndex;\n    return result;\n}",
            "timestamp": 1749469832,
            "statusCode": 15,
            "user": {
                "username": "ZRlvkAicEr",
                "profile": {
                    "realName": "ZRlvkAicEr",
                    "userAvatar": "https://assets.leetcode.com/users/ZRlvkAicEr/avatar_1749245074.png"
                }
            },
            "lang": {
                "name": "c",
                "verboseName": "C"
            },
            "question": {
                "questionId": "30",
                "titleSlug": "substring-with-concatenation-of-all-words",
                "hasFrontendPreview": false
            },
            "notes": "",
            "flagType": "WHITE",
            "topicTags": [],
            "runtimeError": "Line 41:\n=================================================================\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x5020000000f0 at pc 0x556e61f2ab3b bp 0x7ffc33166800 sp 0x7ffc331667f0\nREAD of size 1 at 0x5020000000f0 thread T0\n    #0 0x556e61f2ab3a in hashFunction solution.c:41\n    #1 0x556e61f2ab3a in get solution.c:41\n    #2 0x556e61f2af3d in findSubstring solution.c:41\n    #3 0x556e61f29695 in main solution.c:41\n    #4 0x7ff2074091c9  (/lib/x86_64-linux-gnu/libc.so.6+0x2a1c9) (BuildId: 6d64b17fbac799e68da7ebd9985ddf9b5cb375e6)\n    #5 0x7ff20740928a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2a28a) (BuildId: 6d64b17fbac799e68da7ebd9985ddf9b5cb375e6)\n    #6 0x556e61f29c24 in _start (solution+0x20c24) (BuildId: e5935ec492ebf2df258400e3ca1bc6885993054c)\n0x5020000000f0 is located 0 bytes inside of 4-byte region [0x5020000000f0,0x5020000000f4)\nfreed by thread T0 here:\n    #0 0x7ff207dec4d8 in free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:52\n    #1 0x556e61f2af32 in findSubstring solution.c:41\n    #2 0x556e61f29695 in main solution.c:41\n    #3 0x7ff2074091c9  (/lib/x86_64-linux-gnu/libc.so.6+0x2a1c9) (BuildId: 6d64b17fbac799e68da7ebd9985ddf9b5cb375e6)\n    #4 0x7ff20740928a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2a28a) (BuildId: 6d64b17fbac799e68da7ebd9985ddf9b5cb375e6)\n    #5 0x556e61f29c24 in _start (solution+0x20c24) (BuildId: e5935ec492ebf2df258400e3ca1bc6885993054c)\npreviously allocated by thread T0 here:\n    #0 0x7ff207ded9c7 in malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:69\n    #1 0x556e61f2af5d in findSubstring solution.c:41\n    #2 0x556e61f29695 in main solution.c:41\n    #3 0x7ff2074091c9  (/lib/x86_64-linux-gnu/libc.so.6+0x2a1c9) (BuildId: 6d64b17fbac799e68da7ebd9985ddf9b5cb375e6)\n    #4 0x7ff20740928a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2a28a) (BuildId: 6d64b17fbac799e68da7ebd9985ddf9b5cb375e6)\n    #5 0x556e61f29c24 in _start (solution+0x20c24) (BuildId: e5935ec492ebf2df258400e3ca1bc6885993054c)\nSUMMARY: AddressSanitizer: heap-use-after-free solution.c:41 in hashFunction\nShadow bytes around the buggy address:\n  0x501ffffffe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501ffffffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501fffffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501fffffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x502000000000: fa fa 00 00 fa fa 04 fa fa fa 04 fa fa fa 00 00\n=>0x502000000080: fa fa 04 fa fa fa 04 fa fa fa 00 00 fa fa[fd]fa\n  0x502000000100: fa fa 04 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000180: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000280: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==23==ABORTING",
            "compileError": null,
            "lastTestcase": "\"barfoothefoobarman\"\n[\"foo\",\"bar\"]",
            "codeOutput": "",
            "expectedOutput": "[0,9]",
            "totalCorrect": 0,
            "totalTestcases": 182,
            "fullCodeOutput": null,
            "testDescriptions": null,
            "testBodies": null,
            "testInfo": null,
            "stdOutput": ""
        }
    }
}